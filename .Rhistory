for (v in seq_along(unorders)) {
order <- unorders[v]
for (vi in seq_along(morders)) {
lstoerds <- unlist(morders[vi])
cnames <- as.numeric(names(morders[vi]))
if (order %in% lstoerds == TRUE) ccodes[v, vi] <- cnames else ccodes[v] <- NA
}
}
row.names(ccodes) <- unorders
# extract all matrix rows, remove NAs and maintain the ecoparams for each taxa
taxafinal0 <- apply(ccodes, 1, FUN = function(x) unlist(x)[!is.na(unlist(x))])
taxafinal <- taxafinal0[ sapply(taxafinal0, length) >0]
# get the base url for the taxa data tables
qurl <- "https://www.freshwaterecology.info/fweapi2/v1/query"
sapply(names(taxafinal), function(y) {
codes <- taxafinal[[1]]
ldataxx <- httr2::request(base_url = qurl) |>
httr2::req_auth_bearer_token(token = tokencode) |>
httr2::req_body_raw(body = jsonlite::toJSON(
list(
organismgroup = taxaharmonised, taxagroup = "Crustecea",
displayValues = list(ecologicalparameter = codes)
),
auto_unbox = TRUE
), type = "application/json") |>
httr2::req_perform()
ldataxx <- httr2::request(base_url = qurl) |>
httr2::req_auth_bearer_token(token = tokencode) |>
httr2::req_body_raw(body = jsonlite::toJSON(
list(
organismgroup = taxaharmonised, taxagroup = "Crustecea",
displayValues = list(ecologicalparameter = codes)
),
auto_unbox = TRUE
), type = "application/json") |>
httr2::req_perform()
fxdatax1 <- ldataxx |> httr2::resp_body_json()
macro <- as.data.frame(do.call(rbind, fxdatax1$searchResult))
unregister_dopar <- function() {
env <- foreach:::.foreachGlobals
rm(list=ls(name=env), pos=env)
}
unregister_dopar()
unregister_dopar()
tokencode <- fip_token()
devtools::load_all(".")
tokencode <- fip_token()
getparam_list <- fip_paramlist()
# extract parameters
ecolist <- getparam_list$ecologicalParameterList # requires only fi, mi, pb, pp, pd, di
# get for each taxa
taxaharmonised <- harmonisetaxa(tx = 'mi', taxafile = TRUE)
gettaxa <- ecolist[[taxaharmonised]]
# extract data for macro invertebrates
# get all list available for traits
morders <- sapply(gettaxa, function(x) strsplit(x[["availableFor"]], split = ", ", fixed = TRUE)[[1]])
codes <- sapply(gettaxa, function(x) x[[1]])
mnames <- sapply(gettaxa, function(x) x[[2]])
# merge all lists and make them unique
names(morders) <- codes
unorders <- unique(do.call(c, morders))
ccodes <- matrix(NA, nrow = length(unorders), ncol = length(morders))
for (v in seq_along(unorders)) {
order <- unorders[v]
for (vi in seq_along(morders)) {
lstoerds <- unlist(morders[vi])
cnames <- as.numeric(names(morders[vi]))
if (order %in% lstoerds == TRUE) ccodes[v, vi] <- cnames else ccodes[v] <- NA
}
}
row.names(ccodes) <- unorders
# extract all matrix rows, remove NAs and maintain the ecoparams for each taxa
taxafinal0 <- apply(ccodes, 1, FUN = function(x) unlist(x)[!is.na(unlist(x))])
taxafinal <- taxafinal0[ sapply(taxafinal0, length) >0]
# get the base url for the taxa data tables
qurl <- "https://www.freshwaterecology.info/fweapi2/v1/query"
codes <- taxafinal[[1]]
ldataxx <- httr2::request(base_url = qurl) |>
httr2::req_auth_bearer_token(token = tokencode) |>
httr2::req_body_raw(body = jsonlite::toJSON(
list(
organismgroup = taxaharmonised, taxagroup = "Crustecea",
displayValues = list(ecologicalparameter = codes)
),
auto_unbox = TRUE
), type = "application/json") |>
httr2::req_perform()
ldataxx <- httr2::request(base_url = qurl) |>
httr2::req_auth_bearer_token(token = tokencode) |>
httr2::req_body_raw(body = jsonlite::toJSON(
list(
organismgroup = taxaharmonised, taxagroup = "Crustacea",
displayValues = list(ecologicalparameter = codes)
),
auto_unbox = TRUE
), type = "application/json") |>
httr2::req_perform()
fxdatax1 <- ldataxx |> httr2::resp_body_json()
macro <- as.data.frame(do.call(rbind, fxdatax1$searchResult))
ldataxx <- httr2::request(base_url = qurl) |>
httr2::req_auth_bearer_token(token = tokencode) |>
httr2::req_body_raw(body = jsonlite::toJSON(
list(
organismgroup = taxaharmonised, taxagroup = "Crustacea",
displayValues = list(ecologicalparameter = codes)
),
auto_unbox = TRUE
), type = "application/json") |>
httr2::req_perform()
get_mmacro_pb <- function(taxa, token) {
# get database map
getparam_list <- fip_paramlist()
# extract parameters
ecolist <- getparam_list$ecologicalParameterList # requires only fi, mi, pb, pp, pd, di
# get for each taxa
taxaharmonised <- harmonisetaxa(tx = taxa, taxafile = TRUE)
gettaxa <- ecolist[[taxaharmonised]]
# extract data for macro invertebrates
# get all list available for traits
morders <- sapply(gettaxa, function(x) strsplit(x[["availableFor"]], split = ", ", fixed = TRUE)[[1]])
codes <- sapply(gettaxa, function(x) x[[1]])
mnames <- sapply(gettaxa, function(x) x[[2]])
# merge all lists and make them unique
names(morders) <- codes
unorders <- unique(do.call(c, morders))
ccodes <- matrix(NA, nrow = length(unorders), ncol = length(morders))
for (v in seq_along(unorders)) {
order <- unorders[v]
for (vi in seq_along(morders)) {
lstoerds <- unlist(morders[vi])
cnames <- as.numeric(names(morders[vi]))
if (order %in% lstoerds == TRUE) ccodes[v, vi] <- cnames else ccodes[v] <- NA
}
}
row.names(ccodes) <- unorders
# extract all matrix rows, remove NAs and maintain the ecoparams for each taxa
taxafinal0 <- apply(ccodes, 1, FUN = function(x) unlist(x)[!is.na(unlist(x))])
taxafinal <- taxafinal0[ sapply(taxafinal0, length) >0]
# get the base url for the taxa data tables
qurl <- "https://www.freshwaterecology.info/fweapi2/v1/query"
sapply(names(taxafinal), function(y) {
taxanames <- y
codes <- taxafinal[[y]]
ldataxx <- httr2::request(base_url = qurl) |>
httr2::req_auth_bearer_token(token = tokencode) |>
httr2::req_body_raw(body = jsonlite::toJSON(
list(
organismgroup = taxaharmonised, taxagroup = taxanames,
displayValues = list(ecologicalparameter = codes)
),
auto_unbox = TRUE
), type = "application/json") |>
httr2::req_er
httr2::req_perform()
fxdatax1 <- ldataxx |> httr2::resp_body_json()
macro <- as.data.frame(do.call(rbind, fxdatax1$searchResult))
return(macro)
}, simplify = FALSE, USE.NAMES = TRUE)
}
get_mmacro_pb <- function(taxa, token) {
# get database map
getparam_list <- fip_paramlist()
# extract parameters
ecolist <- getparam_list$ecologicalParameterList # requires only fi, mi, pb, pp, pd, di
# get for each taxa
taxaharmonised <- harmonisetaxa(tx = taxa, taxafile = TRUE)
gettaxa <- ecolist[[taxaharmonised]]
# extract data for macro invertebrates
# get all list available for traits
morders <- sapply(gettaxa, function(x) strsplit(x[["availableFor"]], split = ", ", fixed = TRUE)[[1]])
codes <- sapply(gettaxa, function(x) x[[1]])
mnames <- sapply(gettaxa, function(x) x[[2]])
# merge all lists and make them unique
names(morders) <- codes
unorders <- unique(do.call(c, morders))
ccodes <- matrix(NA, nrow = length(unorders), ncol = length(morders))
for (v in seq_along(unorders)) {
order <- unorders[v]
for (vi in seq_along(morders)) {
lstoerds <- unlist(morders[vi])
cnames <- as.numeric(names(morders[vi]))
if (order %in% lstoerds == TRUE) ccodes[v, vi] <- cnames else ccodes[v] <- NA
}
}
row.names(ccodes) <- unorders
# extract all matrix rows, remove NAs and maintain the ecoparams for each taxa
taxafinal0 <- apply(ccodes, 1, FUN = function(x) unlist(x)[!is.na(unlist(x))])
taxafinal <- taxafinal0[ sapply(taxafinal0, length) >0]
# get the base url for the taxa data tables
qurl <- "https://www.freshwaterecology.info/fweapi2/v1/query"
sapply(names(taxafinal), function(y) {
taxanames <- y
codes <- taxafinal[[y]]
ldataxx <- httr2::request(base_url = qurl) |>
httr2::req_auth_bearer_token(token = tokencode) |>
httr2::req_body_raw(body = jsonlite::toJSON(
list(
organismgroup = taxaharmonised, taxagroup = taxanames,
displayValues = list(ecologicalparameter = codes)
),
auto_unbox = TRUE
), type = "application/json") |>
httr2::req_perform()
fxdatax1 <- ldataxx |> httr2::resp_body_json()
macro <- as.data.frame(do.call(rbind, fxdatax1$searchResult))
return(macro)
}, simplify = FALSE, USE.NAMES = TRUE)
}
getpb <- get_mmacro_pb(taxa = "mi", token = tokencode)
library(httr2)
req <- request("https://fakerapi.it/api/v1")
resp <- req |>
# Then we add on the images path
req_url_path_append("images") |>
# Add query parameters _width and _quantity
req_url_query(`_width` = 380, `_quantity` = 1) |>
req_perform()
resp |> resp_body_json() |> str()
req |>
req_url_path_append("invalid") |>
req_perform()
resp <- last_response()
resp |> resp_body_json()
req |>
req_user_agent("my_package_name (http://my.package.web.site)") |>
req_dry_run()
req |>
req_user_agent("fwtraits ((https://boku.ac.at/personen/person/06473192FC3B0438)") |>
req_dry_run()
#error handling
resp <- request("https://api.nytimes.com/svc/books/v3") |>
req_url_path_append("/reviews.json") |>
req_url_query(`api-key` = "invalid", isbn = 9780307476463) |>
req_perform()
resp <- last_response()
resp
resp |> resp_body_json()
resp |> resp_body_json() |> _$fault |> _$faultstring
nytimes_error_body <- function(resp) {
resp |> resp_body_json() |> _$fault |> _$faultstring
}
resp <- request("https://api.nytimes.com/svc/books/v3") |>
req_url_path_append("/reviews.json") |>
req_url_query(`api-key` = "invalid", isbn = 9780307476463) |>
req_error(body = nytimes_error_body) |>
req_perform()
req <- request("https://api.nytimes.com/svc/books/v3") |>
req_url_path_append("/reviews.json") |>
req_url_query(`api-key` = "invalid", isbn = 9780307476463) |>
req_throttle(10 / 60)
req <- request("https://api.nytimes.com/svc/books/v3") |>
req_url_path_append("/reviews.json") |>
req_url_query(`api-key` = "invalid", isbn = 9780307476463) |>
req_throttle(10 / 60, realm = "https://api.nytimes.com/svc/books")
get_mmacro_pb <- function(taxa, token) {
# get database map
getparam_list <- fip_paramlist()
# extract parameters
ecolist <- getparam_list$ecologicalParameterList # requires only fi, mi, pb, pp, pd, di
# get for each taxa
taxaharmonised <- harmonisetaxa(tx = taxa, taxafile = TRUE)
gettaxa <- ecolist[[taxaharmonised]]
# extract data for macro invertebrates
# get all list available for traits
morders <- sapply(gettaxa, function(x) strsplit(x[["availableFor"]], split = ", ", fixed = TRUE)[[1]])
codes <- sapply(gettaxa, function(x) x[[1]])
mnames <- sapply(gettaxa, function(x) x[[2]])
# merge all lists and make them unique
names(morders) <- codes
unorders <- unique(do.call(c, morders))
ccodes <- matrix(NA, nrow = length(unorders), ncol = length(morders))
for (v in seq_along(unorders)) {
order <- unorders[v]
for (vi in seq_along(morders)) {
lstoerds <- unlist(morders[vi])
cnames <- as.numeric(names(morders[vi]))
if (order %in% lstoerds == TRUE) ccodes[v, vi] <- cnames else ccodes[v] <- NA
}
}
row.names(ccodes) <- unorders
# extract all matrix rows, remove NAs and maintain the ecoparams for each taxa
taxafinal0 <- apply(ccodes, 1, FUN = function(x) unlist(x)[!is.na(unlist(x))])
taxafinal <- taxafinal0[ sapply(taxafinal0, length) >0]
# get the base url for the taxa data tables
qurl <- "https://www.freshwaterecology.info/fweapi2/v1/query"
sapply(names(taxafinal), function(y) {
taxanames <- y
codes <- taxafinal[[y]]
ldataxx <- httr2::request(base_url = qurl) |>
httr2::req_auth_bearer_token(token = tokencode) |>
httr2::req_body_raw(body = jsonlite::toJSON(
list(
organismgroup = taxaharmonised, taxagroup = taxanames,
displayValues = list(ecologicalparameter = codes)
),
auto_unbox = TRUE
), type = "application/json") |>
httr2::req_user_agent(string = "fwtraits (anthonybasooma@boku.ac.at)") |>
httr2::req_throttle(10 / 60)|>
httr2::req_perform()
fxdatax1 <- ldataxx |> httr2::resp_body_json()
macro <- as.data.frame(do.call(rbind, fxdatax1$searchResult))
return(macro)
}, simplify = FALSE, USE.NAMES = TRUE)
}
tokencode <- fip_token()
get_mmacro_pb <- function(taxa, token) {
# get database map
getparam_list <- fip_paramlist()
# extract parameters
ecolist <- getparam_list$ecologicalParameterList # requires only fi, mi, pb, pp, pd, di
# get for each taxa
taxaharmonised <- harmonisetaxa(tx = taxa, taxafile = TRUE)
gettaxa <- ecolist[[taxaharmonised]]
# extract data for macro invertebrates
# get all list available for traits
morders <- sapply(gettaxa, function(x) strsplit(x[["availableFor"]], split = ", ", fixed = TRUE)[[1]])
codes <- sapply(gettaxa, function(x) x[[1]])
mnames <- sapply(gettaxa, function(x) x[[2]])
# merge all lists and make them unique
names(morders) <- codes
unorders <- unique(do.call(c, morders))
ccodes <- matrix(NA, nrow = length(unorders), ncol = length(morders))
for (v in seq_along(unorders)) {
order <- unorders[v]
for (vi in seq_along(morders)) {
lstoerds <- unlist(morders[vi])
cnames <- as.numeric(names(morders[vi]))
if (order %in% lstoerds == TRUE) ccodes[v, vi] <- cnames else ccodes[v] <- NA
}
}
row.names(ccodes) <- unorders
# extract all matrix rows, remove NAs and maintain the ecoparams for each taxa
taxafinal0 <- apply(ccodes, 1, FUN = function(x) unlist(x)[!is.na(unlist(x))])
taxafinal <- taxafinal0[ sapply(taxafinal0, length) >0]
# get the base url for the taxa data tables
qurl <- "https://www.freshwaterecology.info/fweapi2/v1/query"
sapply(names(taxafinal), function(y) {
taxanames <- y
codes <- taxafinal[[y]]
ldataxx <- httr2::request(base_url = qurl) |>
httr2::req_auth_bearer_token(token = tokencode) |>
httr2::req_body_raw(body = jsonlite::toJSON(
list(
organismgroup = taxaharmonised, taxagroup = taxanames,
displayValues = list(ecologicalparameter = codes)
),
auto_unbox = TRUE
), type = "application/json") |>
httr2::req_user_agent(string = "fwtraits (anthonybasooma@boku.ac.at)") |>
httr2::req_throttle(10 / 60)|>
httr2::req_perform()
fxdatax1 <- ldataxx |> httr2::resp_body_json()
macro <- as.data.frame(do.call(rbind, fxdatax1$searchResult))
return(macro)
}, simplify = FALSE, USE.NAMES = TRUE)
}
getpb <- get_mmacro_pb(taxa = "mi", token = tokencode)
ldataxx <- httr2::request(base_url = qurl) |>
httr2::req_auth_bearer_token(token = tokencode) |>
httr2::req_body_raw(body = jsonlite::toJSON(
list(
organismgroup = taxaharmonised, taxagroup = "Crustacea",
displayValues = list(ecologicalparameter = codes)
),
auto_unbox = TRUE
), type = "application/json") |>
httr2::req_perform()
codes <- taxafinal[[2]]
ldataxx <- httr2::request(base_url = qurl) |>
httr2::req_auth_bearer_token(token = tokencode) |>
httr2::req_body_raw(body = jsonlite::toJSON(
list(
organismgroup = taxaharmonised, taxagroup = "Ephemeroptera",
displayValues = list(ecologicalparameter = codes)
),
auto_unbox = TRUE
), type = "application/json") |>
httr2::req_perform()
ldataxx <- last_response()
resp
resp |> resp_body_json()
ldataxx
ldataxx |> resp_body_json()
resp <- request("https://api.nytimes.com/svc/books/v3") |>
req_url_path_append("/reviews.json") |>
req_url_query(`api-key` = "invalid", isbn = 9780307476463) |>
req_perform()
resp <- last_response()
resp
resp |> resp_body_json()
ldataxx <- last_response()
ldataxx
ldataxx <- httr2::request(base_url = qurl) |>
httr2::req_auth_bearer_token(token = tokencode) |>
httr2::req_body_raw(body = jsonlite::toJSON(
list(
organismgroup = taxaharmonised, taxagroup = "Ephemeroptera",
displayValues = list(ecologicalparameter = codes)
),
auto_unbox = TRUE
), type = "application/json") |>
httr2::req_perform()
ldataxx
ldataxx <- last_response()
ldataxx
ldataxx |> resp_body_json()
withCallingHandlers(
ldataxx <- httr2::request(base_url = qurl) |>
httr2::req_auth_bearer_token(token = tokencode) |>
httr2::req_body_raw(body = jsonlite::toJSON(
list(
organismgroup = taxaharmonised, taxagroup = "Ephemeroptera",
displayValues = list(ecologicalparameter = codes)
),
auto_unbox = TRUE
), type = "application/json") |>
httr2::req_perform(),
error = function(err) {
rlang::abort("Failed to download user detals", parent = err)
}
withCallingHandlers(
ldataxx <- last_response()
withCallingHandlers(
ldataxx <- httr2::request(base_url = qurl) |>
httr2::req_auth_bearer_token(token = tokencode) |>
httr2::req_body_raw(body = jsonlite::toJSON(
list(
organismgroup = taxaharmonised, taxagroup = "Ephemeroptera",
displayValues = list(ecologicalparameter = codes)
),
auto_unbox = TRUE
), type = "application/json") |>
httr2::req_perform(),
error = function(err) {
rlang::abort("Failed to download user detals", parent = err)
}
)
ldataxx <- httr2::request(base_url = qurl) |>
httr2::req_auth_bearer_token(token = tokencode) |>
httr2::req_body_raw(body = jsonlite::toJSON(
list(
organismgroup = taxaharmonised, taxagroup = "Ephemeroptera",
displayValues = list(ecologicalparameter = codes)
),
auto_unbox = TRUE
), type = "application/json") |>
req_error(is_error = \(resp) FALSE) |>
httr2::req_perform()
ldataxx <- httr2::request(base_url = qurl) |>
httr2::req_auth_bearer_token(token = tokencode) |>
httr2::req_body_raw(body = jsonlite::toJSON(
list(
organismgroup = taxaharmonised, taxagroup = "Ephemeroptera",
displayValues = list(ecologicalparameter = codes)
),
auto_unbox = TRUE
), type = "application/json") |>
req_error(is_error = \(resp) FALSE) |>
httr2::req_perform()
ldataxx <- httr2::request(base_url = qurl) |>
httr2::req_auth_bearer_token(token = tokencode) |>
httr2::req_body_raw(body = jsonlite::toJSON(
list(
organismgroup = taxaharmonised, taxagroup = "Ephemeroptera",
displayValues = list(ecologicalparameter = codes)
),
auto_unbox = TRUE
), type = "application/json") |>
req_error(is_error = \(resp) FALSE) |>
httr2::req_cperform()
ldataxx <- httr2::request(base_url = qurl) |>
httr2::req_auth_bearer_token(token = tokencode) |>
httr2::req_body_raw(body = jsonlite::toJSON(
list(
organismgroup = taxaharmonised, taxagroup = "Ephemeroptera",
displayValues = list(ecologicalparameter = codes)
),
auto_unbox = TRUE
), type = "application/json") |>
req_error(is_error = \(resp) FALSE) |>
httr2::req_perform()
ldataxx
ldataxx <- httr2::request(base_url = qurl) |>
httr2::req_auth_bearer_token(token = tokencode) |>
httr2::req_body_raw(body = jsonlite::toJSON(
list(
organismgroup = taxaharmonised, taxagroup = "Ephemeroptera",
displayValues = list(ecologicalparameter = coes)
),
auto_unbox = TRUE
), type = "application/json") |>
req_error(is_error = \(resp) FALSE) |>
httr2::req_perform()
ldataxx <- httr2::request(base_url = qurl) |>
httr2::req_auth_bearer_token(token = tokencode) |>
httr2::req_body_raw(body = jsonlite::toJSON(
list(
organismgroup = taxaharmonised, taxagroup = "Ephmeroptera",
displayValues = list(ecologicalparameter = codes)
),
auto_unbox = TRUE
), type = "application/json") |>
req_error(is_error = \(resp) FALSE) |>
httr2::req_perform()
ldataxx
codes <- taxafinal[[1]]
tokencode <- fip_token()
install.packages("httr2")
install.packages("httr2")
install.packages("httr2")
install.packages("httr2")
